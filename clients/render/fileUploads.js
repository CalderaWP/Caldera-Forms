import {
	createMediaFromFile,
	hashFile,
	removeFromBlocking,
	removeFromPending,
	removeFromUploadStarted,
	setBlocking
} from './util'

/**
 * Manage response of file upload requests
 *
 * @since 1.8.0
 *
 * @param {object} response generated by hashFile() => createMediaFromFile()
 * @param {File} file being responded to
 * @param {object} processData holding {cf2,$form,field,strings,theComponent}
 * @param {object} processFunctions holds {handleFileUploadError}
 * @param {boolean} lastFile true if last file to be processed
 *
 */
export const handleFileUploadResponse = (response, file, processData, processFunctions, lastFile) => {

	const {cf2,$form,field,strings,theComponent} = processData;
	const {handleFileUploadError} = processFunctions;
	const {fieldId} = field;
	if( 'object' !== typeof response ){
		removeFromUploadStarted(fieldId,cf2);
		removeFromPending(fieldId,cf2);
		handleFileUploadError(strings.invalidFileResponse, file, strings, field.fieldIdAttr, theComponent, 'UnknownUploadError');
	}else if (response.hasOwnProperty('control')) {
		removeFromPending(fieldId,cf2);
		removeFromBlocking(fieldId,cf2,field);
		cf2.uploadCompleted.push(fieldId);
		if(lastFile){
			$form.submit();
		}
	}else{
		removeFromUploadStarted(fieldId,cf2);
		removeFromPending(fieldId,cf2);
		handleFileUploadError(response, file, strings, field.fieldIdAttr, theComponent);
	}

};

/**
 * Manage response of file upload failure
 *
 * @since 1.8.0
 *
 * @param {object} error generated by promise
 * @param {File} file blob
 * @param {object} strings Translatable strings of text (localized in enqueue_form_assets() => classes/render/assets.php)
 * @param {string} fieldIdAttr fieldIdAttr of the field we are processing the file for
 * @param {object} theComponent File field component rendered
 *
 */
export const handleFileUploadError = (error, file, strings, fieldIdAttr, theComponent ) => {
	if( error.hasOwnProperty('message') ){
		theComponent.addFieldMessage( fieldIdAttr, error.message , true );
	}else{
		if(file.name) {
			const messageText = strings.fileUploadError1 + file.name + strings.fileUploadError2;
			theComponent.addFieldMessage(fieldIdAttr, messageText, true, 'fileNoErrorMessage');
		} else {
			theComponent.addFieldMessage(fieldIdAttr, 'unKnown Error', true, 'noFileUnknownError');
		}
	}
};

/**
 * Hash a file then upload it
 *
 * @since 1.8.0
 *
 * @param {File} file File blob
 * @param {object} processData object of data to process files {verify, field, fieldId, cf2, $form, CF_API_DATA, messages}
 * @param {object} processFunctions object of functions that will be called within processFiles then test the cases they are called {hashAndUpload, hashFile, createMediaFromFile, handleFileUploadResponse, handleFileUploadError}
 */
export const hashAndUpload = (file, processData, processFunctions ) => {

	const {verify, field, CF_API_DATA, lastFile, theComponent} = processData;
	const {hashFile, createMediaFromFile, handleFileUploadResponse, handleFileUploadError} = processFunctions;

	const API_FOR_FILES_URL = CF_API_DATA.rest.fileUpload;
	const _wp_nonce = CF_API_DATA.rest.nonce;
	const strings = CF_API_DATA.strings.cf2FileField;

	if (file instanceof File || file instanceof Blob) {

		hashFile(file, (hash) => {
			const additonalData = {
				hashes: [hash],
				verify,
				formId: field.formId,
				fieldId: field.fieldId,
				control: field.control,
				_wp_nonce,
				API_FOR_FILES_URL
			}
			createMediaFromFile(file, additonalData, fetch )
			.then(
				response => response.json()
			)
			.then(
				response => handleFileUploadResponse(response, file, processData, processFunctions, lastFile)
			)
			.catch(
				error => {
					handleFileUploadError(error,file,strings, field.fieldIdAttr, theComponent);
				}
			);
		});

	}
}

/**
 * Trigger the process on array of files
 *
 * @since 1.8.0
 *
 * @param {array} files array of Files
 * @param {object} processData object of data to process files {verify, field, fieldId, cf2, $form, CF_API_DATA, messages}
 * @param {object} processFunctions object of functions that will be called within processFiles then test the cases they are called {hashAndUpload, hashFile, createMediaFromFile, handleFileUploadResponse, handleFileUploadError}
 */
export const processFiles = (files, processData, processFunctions) => {

	const {hashAndUpload, handleFileUploadError} = processFunctions;
	const {field, theComponent} = processData;
	const strings = processData.CF_API_DATA.strings.cf2FileField;

	files.forEach(( file, index, array) => {
			if( Array.isArray( file ) ){
				file = file[0];
			}

			if( index === array.length - 1){
				processData.lastFile = true;
			}else{
				processData.lastFile = false;
			}

			try{
				hashAndUpload(file, processData, processFunctions);
			} catch(error){
				handleFileUploadError(error, file, strings, field.fieldIdAttr, theComponent);
			}

		}
	);
}

/**
 * Pre-process Files by File field
 *
 * @since 1.8.0
 *
 * @param {object} processData object of data to process files {obj, values, field, fieldId, cf2, $form, CF_API_DATA, messages}
 * @param {object} processFunctions object of functions that will be called within processFiles then test the cases they are called {hashAndUpload, hashFile, createMediaFromFile, handleFileUploadResponse, handleFileUploadError}
 */
export const processFileField = (processData, processFunctions) => {

	const {processFiles} = processFunctions;
	const {obj, values, cf2, field, fieldId, theComponent, CF_API_DATA} = processData;
	const {fieldIdAttr} = field;
	const strings = CF_API_DATA.strings.cf2FileField;
	let shouldBeValidating = false;
	//do not upload after complete
	if ( cf2.uploadCompleted.includes(fieldId)) {
		removeFromPending(fieldId,cf2);
		removeFromBlocking(fieldId,cf2,field);
		return;
	}
	//do not start upload if it has started uploading
	if (-1 <= cf2.uploadStarted.indexOf(_fieldId => _fieldId === fieldId )
		&& -1 <= cf2.pending.indexOf(_fieldId => _fieldId === fieldId)
	) {
		cf2.uploadStarted.push(fieldId);
		obj.$form.data(fieldId, field.control);
		cf2.pending.push(fieldId);
		processData.verify = jQuery(`#_cf_verify_${field.formId}`).val();
		if( '' === values[fieldId] ){
			if( theComponent.isFieldRequired(fieldIdAttr) ){
				theComponent.addFieldMessage( fieldIdAttr, strings.fieldIsRequired);
				shouldBeValidating = true;
				setBlocking(fieldId,cf2,field);
			}
			removeFromPending(fieldId,cf2);
			return;
		}
		removeFromBlocking(fieldId,cf2,field);
		const files = values[fieldId];
		processFiles(files, processData, processFunctions);
	}
}
