import {
	createMediaFromFile,
	hashFile,
	removeFromBlocking,
	removeFromPending,
	removeFromUploadStarted,
	setBlocking,
	processAnimation
} from './util'

/**
 * Trigger $form.submit when uploadCompleted length === all fields values length
 *
 * @since 1.8.0
 *
 * @param {integer} completed length of cf2.uploadCompleted
 * @param {object} processData holding {theComponent, $form, lastFile}
 *
 */
export const processFormSubmit = (completed, processData) => {

	const {theComponent, $form, lastFile} = processData;

	//Deduct the length of all fields values
	let valuesLength = 0;
	for( const field in theComponent.state.valuesValidity){
		valuesLength += theComponent.state.valuesValidity[field].validValues.length;
	}
	//Check if it matched the length of uploadCompleted
	const lastField = completed.length === valuesLength;

	if(lastFile && lastField){
		$form.submit();
	}
}
/**
 * Manage response of file upload requests
 *
 * @since 1.8.0
 *
 * @param {object} response generated by hashFile() => createMediaFromFile()
 * @param {File} file being responded to
 * @param {object} processData holding {cf2,$form,field,strings,theComponent}
 * @param {object} processFunctions holds {handleFileUploadError}
 *
 */
export const handleFileUploadResponse = (response, file, processData, processFunctions) => {

	const {cf2,field,strings,theComponent,lastFile} = processData;
	const {handleFileUploadError,processFormSubmit} = processFunctions;
	const {fieldId} = field;
	if( 'object' !== typeof response ){
		removeFromUploadStarted(fieldId,cf2);
		removeFromPending(fieldId,cf2);
		handleFileUploadError(strings.invalidFileResponse, file, strings, field.fieldIdAttr, theComponent, 'UnknownUploadError');
	}else if (response.hasOwnProperty('control')) {
		removeFromUploadStarted(fieldId,cf2);
		removeFromPending(fieldId,cf2);
		removeFromBlocking(fieldId,cf2,field);
		cf2.uploadCompleted.push(fieldId);
		if(lastFile){
			processFormSubmit(cf2.uploadCompleted, processData, processFunctions);
		}
	}else{
		removeFromUploadStarted(fieldId,cf2);
		removeFromPending(fieldId,cf2);
		handleFileUploadError(response, file, strings, field.fieldIdAttr, theComponent);
	}

};

/**
 * Manage response of file upload failure
 *
 * @since 1.8.0
 *
 * @param {object} error generated by promise
 * @param {File} file blob
 * @param {object} strings Translatable strings of text (localized in enqueue_form_assets() => classes/render/assets.php)
 * @param {string} fieldIdAttr fieldIdAttr of the field we are processing the file for
 * @param {object} theComponent File field component rendered
 *
 */
export const handleFileUploadError = (error, file, strings, fieldIdAttr, theComponent ) => {
	//Stop spinner animation
	const formIdAttr = theComponent.props.formIdAttr;
	if(formIdAttr.length > 0){
		processAnimation(formIdAttr, false);
	}
	//Display error message
	if( error.hasOwnProperty('message') ){
		theComponent.addFieldMessage( fieldIdAttr, error.message , true );
	}else{
		if(file.name) {
			const messageText = strings.fileUploadError1 + file.name + strings.fileUploadError2;
			theComponent.addFieldMessage(fieldIdAttr, messageText, true, 'fileNoErrorMessage');
		} else {
			theComponent.addFieldMessage(fieldIdAttr, 'unKnown Error', true, 'noFileUnknownError');
		}
	}
};

/**
 * Hash a file then upload it
 *
 * @since 1.8.0
 *
 * @param {File} file File blob
 * @param {object} processData object of data to process files {verify, field, fieldId, cf2, $form, CF_API_DATA, messages}
 * @param {object} processFunctions object of functions that will be called within processFiles then test the cases they are called {hashAndUpload, hashFile, createMediaFromFile, handleFileUploadResponse, handleFileUploadError}
 */
export const hashAndUpload = (file, processData, processFunctions ) => {

	const {verify, field, CF_API_DATA, theComponent} = processData;
	const {hashFile, createMediaFromFile, handleFileUploadResponse, handleFileUploadError} = processFunctions;

	const API_FOR_FILES_URL = CF_API_DATA.rest.fileUpload;
	const _wp_nonce = CF_API_DATA.rest.nonce;
	const strings = CF_API_DATA.strings.cf2FileField;

	if (file instanceof File || file instanceof Blob) {

		hashFile(file, (hash) => {
			const additonalData = {
				hashes: [hash],
				verify,
				formId: field.formId,
				fieldId: field.fieldId,
				control: field.control,
				_wp_nonce,
				API_FOR_FILES_URL
			}
			createMediaFromFile(file, additonalData, fetch )
			.then(
				response => response.json()
			)
			.then(
				response => handleFileUploadResponse(response, file, processData, processFunctions)
			)
			.catch(
				error => {
					handleFileUploadError(error,file,strings, field.fieldIdAttr, theComponent);
				}
			);
		});

	}
}

/**
 * Trigger the process on array of files
 *
 * @since 1.8.0
 *
 * @param {array} files array of Files
 * @param {object} processData object of data to process files {verify, field, fieldId, cf2, $form, CF_API_DATA, messages}
 * @param {object} processFunctions object of functions that will be called within processFiles then test the cases they are called {hashAndUpload, hashFile, createMediaFromFile, handleFileUploadResponse, handleFileUploadError}
 */
export const processFiles = (files, processData, processFunctions) => {

	const {hashAndUpload, handleFileUploadError} = processFunctions;
	const {field, theComponent} = processData;
	const strings = processData.CF_API_DATA.strings.cf2FileField;

	files.forEach(( file, index, array) => {
			if( Array.isArray( file ) ){
				file = file[0];
			}

			if( index === array.length - 1){
				processData.lastFile = true;
			}else{
				processData.lastFile = false;
			}

			try{
				hashAndUpload(file, processData, processFunctions);
			} catch(error){
				handleFileUploadError(error, file, strings, field.fieldIdAttr, theComponent);
			}

		}
	);
}

/**
 * Pre-process Files by File field
 *
 * @since 1.8.0
 *
 * @param {object} processData object of data to process files {obj, values, field, fieldId, cf2, $form, CF_API_DATA, messages}
 * @param {object} processFunctions object of functions that will be called within processFiles then test the cases they are called {hashAndUpload, hashFile, createMediaFromFile, handleFileUploadResponse, handleFileUploadError}
 */
export const processFileField = (processData, processFunctions) => {

	//Process files
	const {processFiles} = processFunctions;
	const {obj, values, cf2, field, fieldId, theComponent, CF_API_DATA} = processData;
	const {fieldIdAttr, isRequired} = field;

	//Start spinner animation
	if( isRequired ){
		if(!jQuery.isEmptyObject(theComponent.state.valuesValidity) && theComponent.state.valuesValidity[fieldIdAttr].valid){
			processAnimation(obj.formIdAttr, true);
		}
	} else {
		processAnimation(obj.formIdAttr, true);
	}

	const strings = CF_API_DATA.strings.cf2FileField;
	let shouldBeValidating = false;
	//do not upload after complete
	if ( cf2.uploadCompleted.includes(fieldId)) {
		removeFromPending(fieldId,cf2);
		removeFromBlocking(fieldId,cf2,field);
		return;
	}
	//do not start upload if it has started uploading
	if (-1 <= cf2.uploadStarted.indexOf(_fieldId => _fieldId === fieldId )
		&& -1 <= cf2.pending.indexOf(_fieldId => _fieldId === fieldId)
	) {
		cf2.uploadStarted.push(fieldId);
		obj.$form.data(fieldId, field.control);
		cf2.pending.push(fieldId);
		processData.verify = jQuery(`#_cf_verify_${field.formId}`).val();
		if( '' === values[fieldId] ){
			if( theComponent.isFieldRequired(fieldIdAttr) ){
				theComponent.addFieldMessage( fieldIdAttr, strings.fieldIsRequired);
				shouldBeValidating = true;
				setBlocking(fieldId,cf2,field);
			}
			removeFromPending(fieldId,cf2);
			return;
		}
		removeFromBlocking(fieldId,cf2,field);
		const files = values[fieldId];
		processFiles(files, processData, processFunctions);
	}
}
